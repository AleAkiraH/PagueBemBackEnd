name: "Deploy Infrastructure"

on:
  workflow_dispatch:
    inputs:
      components:
        description: "Comma-separated components to deploy (all,ecr,lambda,apigateway,dynamodb)"
        required: false
        default: "all"
      aws_region:
        description: 'AWS region'
        required: false
        default: 'us-east-1'
      env:
        description: 'Environment suffix to include in generated backend names (e.g. dev, prod)'
        required: false
        default: 'dev'
      image_tag:
        description: 'Docker image tag to push/use for Lambda (if pushing an image)'
        required: false
        default: 'latest'
      image_dir:
        description: 'Path to Docker context (relative to repository root)'
        required: false
        default: '.'
      image_uri:
        description: '(Optional) existing image URI to use for Lambda (overrides building/pushing)'
        required: false
      lambda_role_name:
        description: '(Optional) IAM role name for Lambda. If the role already exists it will be imported into Terraform state.'
        required: false
        default: ''
      lambda_function_name:
        description: '(Optional) Lambda function name. If the function already exists it will be imported into Terraform state.'
        required: false
        default: ''

jobs:
  preflight:
    name: Preflight checks
    runs-on: ubuntu-latest
    outputs:
      bucket_name: ${{ steps.prepare.outputs.bucket_name }}
      dynamodb_table_name: ${{ steps.prepare.outputs.dynamodb_table_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.aws_region }}

      - name: Install lint tools
        run: |
          python3 -m pip install --upgrade pip yamllint

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.5.0'

      - name: Validate workflow YAML
        run: |
          yamllint .github/workflows/*.yml || true

      - name: Terraform fmt / validate for modules
        run: |
          set -euo pipefail
          for d in infrastructure/*; do
            if [ -d "$d" ]; then
              echo "==> Checking $d"
              terraform -chdir="$d" init -backend=false >/dev/null 2>&1 || true
              terraform -chdir="$d" fmt -check || (echo "terraform fmt check failed in $d" && exit 1)
              terraform -chdir="$d" validate || (echo "terraform validate failed in $d" && exit 1)
            fi
          done

      - name: Prepare backend resource names
        id: prepare
        run: |
          OWNER="${GITHUB_REPOSITORY%%/*}"
          REPO="${GITHUB_REPOSITORY##*/}"
          OWNER_CLEAN=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g' | cut -c1-30)
          REPO_CLEAN=$(echo "$REPO" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g' | cut -c1-30)

          ENV_NAME="${{ github.event.inputs.env }}"
          if [ -z "$ENV_NAME" ]; then ENV_NAME=dev; fi

          BUCKET="${OWNER_CLEAN}-${REPO_CLEAN}-${ENV_NAME}-tfstate"
          DDB="${OWNER_CLEAN}-${REPO_CLEAN}-${ENV_NAME}-tfstate-locks"

          echo "bucket_name=$BUCKET" >> $GITHUB_OUTPUT
          echo "dynamodb_table_name=$DDB" >> $GITHUB_OUTPUT

      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity || (echo "AWS credentials invalid or not provided" >&2 && exit 1)

      - name: Verify backend bucket and DynamoDB lock table
        run: |
          set -euo pipefail
          echo "Checking bucket: ${{ steps.prepare.outputs.bucket_name }}"
          if ! aws s3api head-bucket --bucket "${{ steps.prepare.outputs.bucket_name }}" --region ${{ github.event.inputs.aws_region }} >/dev/null 2>&1; then
            echo "ERROR: Backend S3 bucket '${{ steps.prepare.outputs.bucket_name }}' not found or inaccessible. Run the 'Terraform Backend Setup' workflow." >&2
            exit 1
          fi
          echo "Checking DynamoDB table: ${{ steps.prepare.outputs.dynamodb_table_name }}"
          if ! aws dynamodb describe-table --table-name "${{ steps.prepare.outputs.dynamodb_table_name }}" --region ${{ github.event.inputs.aws_region }} >/dev/null 2>&1; then
            echo "ERROR: Backend DynamoDB table '${{ steps.prepare.outputs.dynamodb_table_name }}' not found or inaccessible. Run the 'Terraform Backend Setup' workflow." >&2
            exit 1
          fi

      - name: Detect conflicting existing resources
        run: |
          set -euo pipefail
          CONFLICTS=0
          REPO_NAME="paguebem-qrreader"
          if aws ecr describe-repositories --repository-names "$REPO_NAME" --region ${{ github.event.inputs.aws_region }} >/dev/null 2>&1; then
            echo "Conflict: ECR repository '$REPO_NAME' already exists. Run the 'Import resources' workflow before Deploy to import it into Terraform state." >&2
            CONFLICTS=1
          fi

          ROLE_NAME="paguebem-qrreader-lambda-role"
          if aws iam get-role --role-name "$ROLE_NAME" --region ${{ github.event.inputs.aws_region }} >/dev/null 2>&1; then
            echo "Conflict: IAM role '$ROLE_NAME' already exists. Run the 'Import resources' workflow before Deploy to import it into Terraform state." >&2
            CONFLICTS=1
          fi

          LAMBDA_NAME="paguebem-qrreader"
          if aws lambda get-function --function-name "$LAMBDA_NAME" --region ${{ github.event.inputs.aws_region }} >/dev/null 2>&1; then
            echo "Conflict: Lambda function '$LAMBDA_NAME' already exists. Run the 'Import resources' workflow before Deploy to import it into Terraform state." >&2
            CONFLICTS=1
          fi

          if [ "$CONFLICTS" -ne 0 ]; then
            exit 1
          fi

  deploy:
    name: Deploy (plan/apply modules)
    needs: preflight
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ github.event.inputs.aws_region }}
      IMAGE_TAG: ${{ github.event.inputs.image_tag }}
      IMAGE_DIR: ${{ github.event.inputs.image_dir }}
      COMPONENTS: ${{ github.event.inputs.components }}
      IMAGE_URI_INPUT: ${{ github.event.inputs.image_uri }}
      BACKEND_BUCKET: ${{ needs.preflight.outputs.bucket_name }}
      BACKEND_TABLE: ${{ needs.preflight.outputs.dynamodb_table_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.5.0'

      - name: Deploy ECR repository (terraform)
        if: ${{ github.event.inputs.components == 'all' || contains(github.event.inputs.components, 'ecr') }}
        id: ecr_apply
        run: |
          set -euo pipefail
          export TF_INPUT=0

          terraform -chdir=infrastructure/ecr init \
            -backend-config="bucket=$BACKEND_BUCKET" \
            -backend-config="dynamodb_table=$BACKEND_TABLE" \
            -backend-config="key=ecr/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" -reconfigure -input=false

          # Determine expected repository name (from module default or variable)
          REPO_NAME="paguebem-qrreader"

          # Note: if the ECR repository already exists, run the manual 'Import Existing Resources' workflow to import it into Terraform state

          # Plan and apply only when changes are detected
          set +e
          terraform -chdir=infrastructure/ecr plan -input=false -detailed-exitcode -out=plan.tfplan -var "region=${{ env.AWS_REGION }}"
          PLAN_EXIT=$?
          set -e

          if [ "$PLAN_EXIT" -eq 0 ]; then
            echo "No changes in ECR module; skipping apply"
            repo_url=$(aws ecr describe-repositories --repository-names "$REPO_NAME" --region $AWS_REGION --query 'repositories[0].repositoryUri' --output text 2>/dev/null | tr -d '\r')
          elif [ "$PLAN_EXIT" -eq 2 ]; then
            echo "Changes detected in ECR module; applying"
            terraform -chdir=infrastructure/ecr apply -input=false -auto-approve plan.tfplan
            repo_url=$(aws ecr describe-repositories --repository-names "$REPO_NAME" --region $AWS_REGION --query 'repositories[0].repositoryUri' --output text 2>/dev/null | tr -d '\r')
          else
            echo "Terraform plan failed with exit code $PLAN_EXIT" >&2
            exit $PLAN_EXIT
          fi

          # set output safely
          echo "repo_url<<EOF" >> $GITHUB_OUTPUT
          echo "$repo_url" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build and push Docker image to ECR
        if: ${{ github.event.inputs.components == 'all' || contains(github.event.inputs, 'ecr') }}
        run: |
          repo_url=${{ steps.ecr_apply.outputs.repo_url }}
          if [ -z "$repo_url" ]; then echo "repo_url not found" && exit 1; fi
          repo_domain=${repo_url%%/*}
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $repo_domain
          docker build -t ${repo_url}:${IMAGE_TAG} $IMAGE_DIR
          docker push ${repo_url}:${IMAGE_TAG}

      - name: Deploy Lambda (terraform)
        if: ${{ github.event.inputs.components == 'all' || contains(github.event.inputs, 'lambda') }}
        id: lambda_apply
        run: |
          set -euo pipefail
          export TF_INPUT=0

          # Determine image_uri: prefer input IMAGE_URI, else use built image
          image_uri="${IMAGE_URI_INPUT}"
          if [ -z "$image_uri" ]; then
            if [ -n "${{ steps.ecr_apply.outputs.repo_url }}" ]; then
              image_uri="${{ steps.ecr_apply.outputs.repo_url }}:${IMAGE_TAG}"
            fi
          fi

          # If still no image_uri, and the Lambda function exists, try to read its current image URI from AWS
          LAMBDA_NAME="${{ github.event.inputs.lambda_function_name }}"
          if [ -z "$LAMBDA_NAME" ]; then
            LAMBDA_NAME="paguebem-qrreader"
          fi
          if [ -z "$image_uri" ]; then
            if aws lambda get-function --function-name "$LAMBDA_NAME" --region $AWS_REGION >/dev/null 2>&1; then
              existing_image=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region $AWS_REGION --query 'Code.ImageUri' --output text 2>/dev/null)
              if [ -n "$existing_image" ] && [ "$existing_image" != "None" ]; then
                image_uri="$existing_image"
                echo "Using existing Lambda image URI for import/plan: $image_uri"
              fi
            fi
          fi

          # If still empty, set a harmless placeholder so terraform doesn't prompt during import
          if [ -z "$image_uri" ]; then
            image_uri="__IMPORT_PLACEHOLDER__"
            echo "No image_uri available; using placeholder for import: $image_uri"
          fi

          terraform -chdir=infrastructure/lambda init \
            -backend-config="bucket=$BACKEND_BUCKET" \
            -backend-config="dynamodb_table=$BACKEND_TABLE" \
            -backend-config="key=lambda/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" -reconfigure -input=false

          # Note: if an IAM role already exists, run the manual 'Import Existing Resources' workflow to import it into Terraform state

          # If the Lambda function already exists in AWS, import it into Terraform state to avoid create errors
          LAMBDA_NAME="${{ github.event.inputs.lambda_function_name }}"
          if [ -z "$LAMBDA_NAME" ]; then
            LAMBDA_NAME="paguebem-qrreader"
          fi
          if aws lambda get-function --function-name "$LAMBDA_NAME" --region $AWS_REGION >/dev/null 2>&1; then
            echo "Lambda function $LAMBDA_NAME exists; importing into Terraform state"
            if ! terraform -chdir=infrastructure/lambda import -lock=false aws_lambda_function.this "$LAMBDA_NAME" -var "image_uri=${image_uri}" -var "region=${AWS_REGION}" -input=false; then
              echo "ERROR: failed to import existing Lambda function $LAMBDA_NAME. Ensure AWS credentials used by Actions have lambda:GetFunction permission." >&2
              exit 1
            fi
          fi

          # Plan and apply only when changes are detected
          set +e
          terraform -chdir=infrastructure/lambda plan -input=false -detailed-exitcode -out=plan.tfplan -var "image_uri=${image_uri}" -var "region=${{ env.AWS_REGION }}"
          PLAN_EXIT=$?
          set -e

          if [ "$PLAN_EXIT" -eq 0 ]; then
            echo "No changes in Lambda module; skipping apply"
            fn_arn=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region $AWS_REGION --query 'Configuration.FunctionArn' --output text 2>/dev/null | tr -d '\r')
            fn_name="$LAMBDA_NAME"
          elif [ "$PLAN_EXIT" -eq 2 ]; then
            echo "Changes detected in Lambda module; applying"
            terraform -chdir=infrastructure/lambda apply -input=false -auto-approve plan.tfplan
            fn_arn=$(terraform -chdir=infrastructure/lambda output -raw function_arn 2>/dev/null | tr -d '\r' || true)
            if [ -z "$fn_arn" ]; then
              fn_arn=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region $AWS_REGION --query 'Configuration.FunctionArn' --output text 2>/dev/null | tr -d '\r')
            fi
            fn_name=$(terraform -chdir=infrastructure/lambda output -raw function_name 2>/dev/null | tr -d '\r' || true)
            if [ -z "$fn_name" ]; then
              fn_name="$LAMBDA_NAME"
            fi
          else
            echo "Terraform plan failed with exit code $PLAN_EXIT" >&2
            exit $PLAN_EXIT
          fi

          # set outputs safely
          echo "fn_arn<<EOF" >> $GITHUB_OUTPUT
          echo "$fn_arn" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "fn_name<<EOF" >> $GITHUB_OUTPUT
          echo "$fn_name" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Deploy API Gateway (terraform)
        if: ${{ github.event.inputs.components == 'all' || contains(github.event.inputs, 'apigateway') }}
        run: |
          set -euo pipefail
          export TF_INPUT=0

          terraform -chdir=infrastructure/apigateway init \
            -backend-config="bucket=$BACKEND_BUCKET" \
            -backend-config="dynamodb_table=$BACKEND_TABLE" \
            -backend-config="key=apigateway/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" -reconfigure -input=false

          set +e
          terraform -chdir=infrastructure/apigateway plan -input=false -detailed-exitcode -out=plan.tfplan -var "lambda_arn=${fn_arn}" -var "lambda_name=${fn_name}" -var "region=${{ env.AWS_REGION }}"
          PLAN_EXIT=$?
          set -e

          if [ "$PLAN_EXIT" -eq 0 ]; then
            echo "No changes in API Gateway module; skipping apply"
          elif [ "$PLAN_EXIT" -eq 2 ]; then
            echo "Changes detected in API Gateway module; applying"
            terraform -chdir=infrastructure/apigateway apply -input=false -auto-approve plan.tfplan
          else
            echo "Terraform plan failed with exit code $PLAN_EXIT" >&2
            exit $PLAN_EXIT
          fi

      - name: Deploy DynamoDB (terraform)
        if: ${{ github.event.inputs.components == 'all' || contains(github.event.inputs, 'dynamodb') }}
        run: |
          set -euo pipefail
          export TF_INPUT=0

          terraform -chdir=infrastructure/dynamodb init \
            -backend-config="bucket=$BACKEND_BUCKET" \
            -backend-config="dynamodb_table=$BACKEND_TABLE" \
            -backend-config="key=dynamodb/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" -reconfigure -input=false

          set +e
          terraform -chdir=infrastructure/dynamodb plan -input=false -detailed-exitcode -out=plan.tfplan -var "region=${{ env.AWS_REGION }}"
          PLAN_EXIT=$?
          set -e

          if [ "$PLAN_EXIT" -eq 0 ]; then
            echo "No changes in DynamoDB module; skipping apply"
          elif [ "$PLAN_EXIT" -eq 2 ]; then
            echo "Changes detected in DynamoDB module; applying"
            terraform -chdir=infrastructure/dynamodb apply -input=false -auto-approve plan.tfplan
          else
            echo "Terraform plan failed with exit code $PLAN_EXIT" >&2
            exit $PLAN_EXIT
          fi

      - name: Output summary
        run: |
          echo "Deployed components: ${COMPONENTS}"
          echo "ECR repo: ${repo_url:-(not created in this run)}"
          echo "Lambda ARN: ${{ steps.lambda_apply.outputs.fn_arn }}"

